
### 8.1 引言

本章介绍Unix系统的进程控制，包括创建新进程、执行程序和进程终止。

### 8.2 进程标识

ID为0的进程通常是调度进程，常常被称为交换进程。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。

ID为1通常是`init`进程，在自举过程结束时由内核调用。`init`通常读取与系统有关的初始化文件。`init`进程决不会终止，它是一个普通的用户进程，但是它以超级用户特权运行。

### 8.3 函数fork

`fork`函数被调用一次，但返回两次。两次返回但区别是子进程的返回值是0，而父进程的返回值则是新建子进程的进程ID。

### 8.4 函数vfork

`vfork`保证子进程先运行

### 8.5 函数exit

子进程是父进程调用`fork`后生成的，如果父进程在子进程之前终止，那么子进程它们的父进程都改变为`init`进程，我们称这些进程由`init`收养。操作过程大致是：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则该进程的父进程改为1。

如果子进程在父进程之前终止，在UNIX中，一个已经终止、但是父进程尚未对其进行善后处理（获取终止子进程的有关信息、释放它仍占用的资源）的进程被称为僵死进程。如果编写一个长期运行的程序，它`fork`了很多子进程，除非父进程等待取得子进程的终止状态，不然这些子进程终止后就会变成僵死进程。父进程可以调用`wait`、`waitpid`处理终止的子进程。

### 8.6 函数wait和waitpid

当一个进程正常或异常终止时，内核就向父进程发送`SIGCHLD`信号。因为子进程终止是个异步事件（可以在父进程运行的任何时候发生），所有这种信号也是内核向父进程发的异步通知。父进程对这种信号的系统默认动作是忽略它，也可以提供一个该信号发生时即被调用执行的函数。

调用`wait`或`waitpid`会发生什么：
- 如果其子进程都还在运行，则阻塞
- 如果一个子进程已经终止，正在父进程获取其终止状态，则取得该子进程的终止状态立即返回
- 如果它没有任何子进程，则立即出错返回

`wait`和`waitpid`的区别：
- 在一个子进程终止前，`wait`使其调用者阻塞，而`waitpid`有一个选项，可以使调用者不阻塞
- `waitpid`并不等待在其调用之后的第一个终止子进程，它有若干个选项，可以控制它所等待的进程

### 8.7 函数waitid 

### 8.8 函数wait3和wait4 

### 8.9 竞争条件

多个进程都企图对共享数据进程处理，而最后的结果又取决于进程运行的顺序时，我们认为发生了竞争条件。如果在`fork`之后某种逻辑显式或隐式地依赖于在`fork`之后是父进程先运行还是子进程运行，那么`fork`函数就会是竞争条件活跃的滋生地。

如果一个进程希望等待一个子进程终止，则它必须调用`wait`函数中的一个。如果一个进程要等待其父进程终止，则可试用下列形式的循环：
```c
while(getppid()!=1){
    sleep(1)
}
```

这种形式的循环称为轮询，它的问题是浪费CPU时间。

为了避免竞争条件和轮询，在多个进程之间需要有某种形式的信号发送和接收方法。在Unix中可以使用信号机制。

### 8.10 函数exec 

### 8.11 更改用户ID和更改组ID

### 8.12 解释器文件

### 8.13 函数system

### 8.14 进程会计

### 8.15 用户标识

### 8.16 进程调度

### 8.17 进程时间
