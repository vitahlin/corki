
### 10.1 引言

信号是软件中断。

信号提供了一种处理异步事件的方法。

### 10.2 信号概念

不存在编号为0的信号。`kill`函数对信号编号为0有特殊对应用，此种信号编号也称为空信号。

很多条件可以产生信号：
- 用户按下某些终端键时，引发终端产生的信号。如果Ctrl+C 
- 硬件产生的信号：除数为0、无效的内存引用等。
- 进程调用`kill`函数可将任意信号发送给另一个进程或进程组
- 用户可用`kill`命令将信号发送给其他进程
- 当检测到某种软件条件已经发生，并应将其通知有关进程时也产生信号。例如SIGURG（网络连接上传来带外的数据）、SIGPIPE（在管道的读进程已终止后，一个进程写此管道）以及SIGALRM(进程所设置的定时器已经超时)

信号是异步事件的经典实例。产生信号的事件对进程而言是随机出现对。进程不能简单地测试一个变量来判断是否发生了一个信号，而是必须告诉内核“在此信号发生时，请执行下列操作”。

信号的处理：
- 忽略此信号。大多数信号都可以使用这种方式处理，但是两种信号不能被忽略。它们是`SIGKILL`和`SIGSTOP`。这两种信号不能被忽略的原因是：它们向内核和超级用户提供了使进程终止或停止的可靠方法。
- 捕捉信号。为了做到这一点，要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。例如，编写一个命令解释器，它将用户的输入解释为命令并执行，当用户键盘产生中断信号后，希望该命令解释器返回到主循环，终止正在为该用户执行的命令。如果捕捉到`SIGCHLD`信号，则表示一个子进程已经终止，所以此信号的捕捉函数可以调用`waitpid`以取得该子进程的进程ID以及它的终止状态。**注意，不能捕捉`SIGKILL`和`SIGSTOP`信号**
- 执行系统默认动作。对大多数信号的系统默认动作就是终止该进程。

### 10.3 函数signal

### 10.4 不可靠的信号

### 10.5 中断的系统调用

### 10.6 可重入函数

可重入函数简单对就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转而OS调度下去执行另外一段代码，而返回控制时不会出现什么错误。
进程捕捉到信号并对其进行处理时，进程正在执行的正常指令序列就被信号处理程序临时中断，它首先执行该信号处理程序中的指令。如果从信号处理程序返回（例如没有调用`exit`或`longjump`），则继续执行在捕捉到信号时进程正在执行的正常指令序列。但在信号处理程序中，不能判断捕捉信号时进程执行到何处。如果进程正在执行`malloc`，在其堆中分配另外到存储空间，而此时由于捕捉到信号而插入执行该信号处理程序，其中又调用`malloc`函数，可能会对进程造成破坏。

**简单的说，在信号处理函数中，不要调用不可重入函数，会对进程对数据结构造成损坏，不可预知结果。**

### 10.7 SIGCLD语义

`SIGCLD`的语义为：子进程状态改变后产生此信号，父进程需要调用一个`wait`函数以确定发生了什么。

对于`SIGCLD`早期的处理方式是：
1. 如果进程明确地将该信号的配置设置为`SIG_IGN`，则调用进程的子进程将不产生僵死进程。这与默认动作`SIG_DFL`不同。子进程在终止时，将其状态丢弃。如果调用进程随后调用一个`wait`函数，那么它将阻塞直到所有子进程都终止，然后该`wait`会返回-1，并将其`errno`设置为`ECHILD`。

2. 如果将`SIGCLD`的配置设置为捕捉，则内核立即检查是否有子进程准备好被等待，如果是这样，则调用`SIGCLD`处理程序。

一般，父进程在生成子进程后有两种情况，一种是父进程继续做别的事情，一种是父进程啥也不做，一直在`wait`子进程退出。`SIGCLD`信号就是为第一种情况准备的，它让父进程去做别的事情，而只要父进程注册了处理该信号的函数，在子进程退出时就会调用该函数，在该函数中又可以调用`wait`得到终止的子进程的状态。处理信号函数执行完后，再继续父进程的事情。也就是说，如果父进程`fork`之后调用`wait`，就会阻塞，直到有一个子进程退出。
如果父进程在`fork`之前先注册了`SIGCLD`的信号处理函数，然后做自己的事情。当子进程退出时，会给父进程发送一个`SIGCLD`信号，然后信号处理函数就会执行。可以在信号处理函数中调用`wait`获得子进程退出时的状态，并且此时`wait`不会阻塞，当韩式执行完成后，父进程又可以做自己的事情。

### 10.8 可靠信号术语和语义

当造成信号的事件发生时，为进程产生一个信号（或向一个进程发送一个信号）。事件可以是硬件异常（如除以0）、软件条件（如alram定时器超时）、终端产生的信号或调用kill函数。当一个信号产生时，内核通常在进程表以某种形式设置一个标志。

当对信号采取了这种动作时，我们说向进程传递了一个信号。在信号产生和递送之间的时间间隔内，称信号是未决的。
进程可以选用“阻塞信号递送”。如果为进程产生了一个阻塞的信号，而且对该信号的动作是系统默认动作或捕捉该信号，则为该进程将此信号保持为未决状态，直到该进程对此信号解除了阻塞，或者将对此信号的动作更改为忽略。内核在递送一个原来被阻塞的信号给进程时（而不是在产生该信号时），才决定它的处理方式。于是进程在信号递送给它之前仍可改变对该信号的动作。进程调用`sigpending`函数来判定哪些信号是设置为阻塞并处于未决状态的。

如果信号发生了多次，POSIX.1允许系统递送该信号一次或者多次。如果递送该信号多次，则称这些信号进行了排队。但是除非支持POSIX.1实时扩展，否则大多数Unix并不对信号排队，而且只递送一次。

如果有多个信号要递送给一个进程，那么POSIX.1建议在其他信号之前递送与进程当前状态有关的信号，如SIGSEGV。

每个进程都有一个信号屏蔽字，它规定了当前要阻塞递送到该进程的信号集。进程可以调用`sigprocmask`来检测和更改其当前信号屏蔽字。
POSIX.1定义了一个新数据类型`sigset_t`可以容纳一个信号集。

### 10.9 函数kill和raise

### 10.10 函数alarm和pause

`alarm`可以设置一个定时器，在将来的某个时刻该定时器会超时。当定时器超时时，产生`SIGALRM`信号。如果忽略或不捕捉该信号，则其默认动作是终止调用该`alarm`函数的进程。

每个进程只能有一个闹钟时间。如果在调用`alarm`时，之前已为该进程注册的闹钟时间还没有超时，则该闹钟时间的余留值作为本次`alarm`函数调用的值返回。以前注册的闹钟时间则被新值替代。如果有以前注册的尚未超过的闹钟时间，而且本次调用的`seconds`值是0，则取消以前的闹钟时间，其余留值仍作为`alarm`函数的返回值。

### 10.11 信号集

信号集能表示多个信号。

在`sigprocmask`类函数中可以使用这种数据类型，以便告诉内核不允许发生该信号集中的信号。

### 10.12 函数sigprocmask

调用`sigprocmask`可以检测或者更改，或同时进行检测和更改进程的信号屏蔽字。

### 10.13 函数sigpending

`sigpending`函数返回一信号集，对于调用进程而言，其中的各信号是阻塞不能递送的，因而也一定是当前未决的。